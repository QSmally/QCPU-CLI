
// Semantic Analysed Intermediate Representation

const std = @import("std");
const AsmAst = @import("AsmAst.zig");
const Error = @import("Error.zig");
const Qcu = @import("Qcu.zig");
const Source = @import("Source.zig");
const Token = @import("Token.zig");

const AsmSemanticAir = @This();

/// A semantic analyser can be initialised in 'freestanding' mode, which
/// removes any file context and coupling for testing by not depending on the
/// QCPU compilation unit.
qcu: ?*Qcu.File,
allocator: std.mem.Allocator,
source: Source,
nodes: []const AsmAst.Node,
/// May not be modified during semantic analysis.
/// fixme: force namespaces to remove cross duplication problem?
imports: FileList,
/// Any symbol in the current unit. May not be modified during semantic
/// analysis.
symbols: SymbolMap,
sections: SectionMap,
current_section: ?*Section,
/// Only populated in freestanding.
errors: ErrorList,

pub fn init(qcu: *Qcu.File) !AsmSemanticAir {
    var self = AsmSemanticAir {
        .qcu = qcu,
        .allocator = qcu.allocator,
        .source = qcu.source,
        .nodes = qcu.nodes,
        .imports = .empty,
        .symbols = .empty,
        .sections = .empty,
        .current_section = null,
        .errors = .empty };
    errdefer self.deinit();
    try self.prepare_root();
    return self;
}

pub fn init_freestanding(allocator: std.mem.Allocator, source: Source, nodes: []const AsmAst.Node) !AsmSemanticAir {
    var self = AsmSemanticAir {
        .allocator = allocator,
        .qcu = null,
        .source = source,
        .nodes = nodes,
        .imports = .empty,
        .symbols = .empty,
        .sections = .empty,
        .current_section = null,
        .errors = .empty };
    errdefer self.deinit();
    try self.prepare_root();
    return self;
}

fn destroy_section(self: *AsmSemanticAir, section: *Section) void {
    if (section.next) |next|
        self.destroy_section(next);
    section.content.deinit(self.allocator);
    self.allocator.destroy(section);
}

pub fn deinit(self: *AsmSemanticAir) void {
    self.imports.deinit(self.allocator);
    self.symbols.deinit(self.allocator);

    for (self.sections.values()) |section|
        self.destroy_section(section);
    self.sections.deinit(self.allocator);
    self.current_section = null;

    for (self.errors.items) |err|
        self.allocator.free(err.message);
    self.errors.deinit(self.allocator);
}

pub const SymbolFile = struct {
    path: []const u8,
    namespace: ?[]const u8,
    sema_unit: ?*const AsmSemanticAir = null
};

pub const Symbol = union(enum) {

    pub const Locatable = struct {
        token: Token,
        symbol: Symbol
    };

    label: Label,
    define: Define,
    header: Header,

    pub const Label = struct {
        instr_node: AsmAst.Index,
        is_public: bool
    };

    pub const Define = struct {
        value_node: AsmAst.Index,
        is_public: bool
    };

    pub const Header = struct {
        arguments: AsmAst.IndexRange,
        content: AsmAst.IndexRange,
        is_public: bool
    };
};

pub const Section = struct {

    /// Grows with the use of @align to ensure the correct padding is calculated
    /// ahead-of-time.
    alignment: usize = 0,
    /// A boolean to indicate whether this section is allowed to be removed by
    /// unreachable-code-elimination.
    is_removable: bool = true,
    /// Opaque list of (pseudo)instructions. All addresses during assembletime
    /// are relative to the start of the section.
    content: InstructionList = .empty,
    /// A section is allowed to be split by @barrier or duplicate @section
    /// tags, which links to a new, unnamed section.
    next: ?*Section = null,

    pub fn append(self: *Section, new_section: *Section) void {
        if (self.next) |next_section|
            return next_section.append(new_section);
        self.next = new_section;
    }
};

const FileList = std.ArrayListUnmanaged(SymbolFile);
const SymbolMap = std.StringArrayHashMapUnmanaged(Symbol.Locatable);
const SectionMap = std.StringArrayHashMapUnmanaged(*Section);
const InstructionList = std.ArrayListUnmanaged(Instruction);
const ErrorList = std.ArrayListUnmanaged(Error);
const SemanticAirMap = std.StringArrayHashMapUnmanaged(*AsmSemanticAir);

/// SemanticAir will assume certain state generated by AstGen, and asserts them
/// for debugging purposes. If an assumption is not met, SemanticAir will
/// panic.
fn astgen_assert(ok: bool) void {
    if (!ok) unreachable;
}

fn astgen_failure() noreturn {
    unreachable;
}

/// To calculate alignment.
fn find_available_mask(from_address: usize, mask: usize) usize {
    for (from_address..std.math.maxInt(usize)) |address|
        if (address % mask == 0)
            return address;
    unreachable;
}

/// Instructions are variably sized, which requires the size of a section to be
/// calculated iteratively.
fn find_section_size(section: *Section) usize {
    var address: usize = 0;
    for (section.content.items) |instruction|
        address += instruction.size();
    return address;
}

fn node_is_null_or(self: *AsmSemanticAir, index: AsmAst.Index, tag: AsmAst.Node.Tag) bool {
    return index == AsmAst.Null or self.nodes[index].tag == tag;
}

fn node_is(self: *AsmSemanticAir, index: AsmAst.Index, tag: AsmAst.Node.Tag) bool {
    return index != AsmAst.Null and self.nodes[index].tag == tag;
}

fn node_len(self: *AsmSemanticAir, index: AsmAst.Index) ?u32 {
    if (!node_is(index, .container))
        return null;
    const node = self.nodes[index];
    return node.operands.rhs - node.operands.lhs;
}

fn not_null(self: *AsmSemanticAir, index: AsmAst.Index) bool {
    _ = self;
    return index != AsmAst.Null;
}

fn is_null(self: *AsmSemanticAir, index: AsmAst.Index) bool {
    _ = self;
    return index == AsmAst.Null;
}

fn node_unwrap(self: *AsmSemanticAir, index: AsmAst.Index) ?AsmAst.Node {
    return if (self.not_null(index)) self.nodes[index] else null;
}

const ContainerIterator = struct {

    sema: *AsmSemanticAir,
    cursor: AsmAst.Index,
    start: AsmAst.Index,
    end: AsmAst.Index,
    context_token: ?Token = null,

    pub fn init(sema: *AsmSemanticAir, node: AsmAst.Node) ContainerIterator {
        return .{
            .sema = sema,
            .cursor = 0,
            .start = node.operands.lhs,
            .end = node.operands.rhs };
    }

    pub fn init_range(sema: *AsmSemanticAir, range: AsmAst.IndexRange) ContainerIterator {
        return .{
            .sema = sema,
            .cursor = 0,
            .start = range.lhs,
            .end = range.rhs };
    }

    pub fn init_index(sema: *AsmSemanticAir, index: AsmAst.Index) ContainerIterator {
        if (index == AsmAst.Null)
            return .{ .sema = sema, .cursor = 0, .start = 0, .end = 0 };
        const node = sema.nodes[index];
        return ContainerIterator.init(sema, node);
    }

    pub fn init_index_context(sema: *AsmSemanticAir, index: AsmAst.Index, context_token: Token) ContainerIterator {
        var iterator = ContainerIterator.init_index(sema, index);
        iterator.context_token = context_token;
        return iterator;
    }

    pub fn expect_empty(sema: *AsmSemanticAir, index: AsmAst.Index, context_token: Token) !void {
        var iterator = ContainerIterator.init_index_context(sema, index, context_token);
        try iterator.expect_end();
    }

    fn is_the_end(self: *ContainerIterator) bool {
        return self.current() == self.end or self.start == self.end;
    }

    fn current(self: *ContainerIterator) AsmAst.Index {
        return self.start + self.cursor;
    }

    fn current_token(self: *ContainerIterator) Token {
        const node = self.sema.nodes[self.current()];
        return self.sema.source.tokens[node.token];
    }

    pub fn next(self: *ContainerIterator) ?AsmAst.Node {
        if (self.is_the_end())
            return null;
        const index = self.current();
        self.cursor += 1;
        return self.sema.nodes[index];
    }

    pub fn expect(self: *ContainerIterator, tag: AsmAst.Node.Tag) !?AsmAst.Node {
        if (self.is_the_end()) {
            if (self.context_token) |context_token_|
                try self.sema.add_error(error.ExpectedContext, .{ tag, context_token_ }) else
                try self.sema.add_error(error.ExpectedEmpty, tag);
            return null;
        } else if (self.sema.nodes[self.current()].tag != tag) {
            try self.sema.add_error(error.Expected, .{ tag, self.current_token() });
            return null;
        }
        return self.next();
    }

    pub fn gracefully_expect(self: *ContainerIterator, tag: AsmAst.Node.Tag) !?AsmAst.Node {
        if (self.is_the_end())
            return null;
        if (self.sema.nodes[self.current()].tag != tag) {
            try self.sema.add_error(error.Expected, .{ tag, self.current_token() });
            return null;
        }
        return self.next();
    }

    pub fn expect_any(self: *ContainerIterator) !?AsmAst.Index {
        if (self.is_the_end()) {
            const str = Token.string("an argument");
            if (self.context_token) |context_token_|
                try self.sema.add_error(error.ExpectedContext, .{ str, context_token_ }) else
                try self.sema.add_error(error.ExpectedEmpty, str);
            return null;
        }

        _ =  self.next();
        return self.current();
    }

    pub fn expect_end(self: *ContainerIterator) !void {
        if (!self.is_the_end())
            try self.sema.add_error(error.Unexpected, self.current_token());
    }
};

const SemanticError = error {
    Expected,
    ExpectedContext,
    ExpectedEmpty,
    Unexpected,
    UnsupportedOption,
    UselessSentinel,
    DuplicateSymbol,
    AlignPowerTwo,
    RegionExceedsSize,
    NonEmptyModifier,
    ModifiedInstructionUnknown,
    InstructionUnknown,
    ExpectedArgumentsLen,
    NoteDefinedHere,
    NoteDidYouMean,
    Generic,
    GenericToken
};

fn add_error(self: *AsmSemanticAir, comptime err: SemanticError, argument: anytype) !void {
    @branchHint(.unlikely);

    const message = switch (err) {
        error.Expected => "expected {s}, found {s}",
        error.ExpectedContext => "expected {s} in {s}",
        error.ExpectedEmpty => "expected {s}",
        error.Unexpected => "unexpectedly got {s}",
        error.UnsupportedOption => "unsupported option: {s}",
        error.UselessSentinel => "useless sentinel",
        error.DuplicateSymbol => "duplicate symbol '{s}'",
        error.AlignPowerTwo => "alignment of {} is not a power of two",
        error.RegionExceedsSize => "region of opaque size {} exceeds fixed region of {} bytes",
        error.NonEmptyModifier => "an empty modifier value is required, but {s} was used",
        error.ModifiedInstructionUnknown => "instruction {s} doesn't support a modifier",
        error.InstructionUnknown => "unknown instruction in the QCPU instruction set",
        error.ExpectedArgumentsLen => "expected {} {s} for instruction {s}, found {}",
        error.NoteDefinedHere => "{s} defined here",
        error.NoteDidYouMean => "did you mean to {s}{s}?",
        error.Generic,
        error.GenericToken => "{s}: {s}"
    };

    const is_note = switch (err) {
        error.NoteDefinedHere,
        error.NoteDidYouMean => true,
        else => false
    };

    const token: ?Token = switch (err) {
        error.Expected,
        error.ExpectedContext,
        error.DuplicateSymbol,
        error.AlignPowerTwo,
        error.NonEmptyModifier,
        error.NoteDefinedHere => argument[1],
        error.Unexpected,
        error.UnsupportedOption,
        error.UselessSentinel,
        error.ModifiedInstructionUnknown,
        error.InstructionUnknown => argument,
        error.ExpectedArgumentsLen => argument[0],
        error.RegionExceedsSize,
        error.NoteDidYouMean,
        error.GenericToken => argument[2],
        else => null
    };
    const token_location = if (token) |token_|
        self.source.location_of(token_.location) else
        null;
    const token_slice = if (token) |token_|
        token_.location.slice(self.source.buffer) else
        null;
    const arguments = switch (err) {
        error.Expected,
        error.ExpectedContext => .{ argument[0].fmt(), argument[1].tag.fmt() },
        error.ExpectedEmpty => .{ argument.fmt() },
        error.Unexpected => .{ argument.tag.fmt() },
        error.UnsupportedOption,
        error.ModifiedInstructionUnknown => .{ token_slice.? },
        error.UselessSentinel,
        error.InstructionUnknown => .{},
        error.DuplicateSymbol,
        error.AlignPowerTwo,
        error.NonEmptyModifier => .{ argument[0] },
        error.RegionExceedsSize,
        error.NoteDidYouMean,
        error.GenericToken => .{ argument[0], argument[1] },
        error.ExpectedArgumentsLen => blk: {
            const plural = if (argument[1] != 1) "arguments" else "argument";
            break :blk .{ argument[1], plural, token_slice.?, argument[2] };
        },
        error.NoteDefinedHere => .{ argument[0].fmt() },
        else => argument
    };

    const format = try std.fmt.allocPrint(self.allocator, message, arguments);

    const err_data = Error {
        .id = err,
        .token = token,
        .is_note = is_note,
        .message = format,
        .location = token_location };
    if (self.qcu) |qcu|
        try qcu.add_error(err_data) else
        try self.errors.append(self.allocator, err_data);
}

fn prepare_root(self: *AsmSemanticAir) !void {
    astgen_assert(self.nodes.len > 0);
    astgen_assert(self.nodes[0].tag == .container);
    try self.prepare_opaque_container(self.nodes[0]);
}

fn prepare_opaque_container(self: *AsmSemanticAir, parent_node: AsmAst.Node) !void {
    for (parent_node.operands.lhs..parent_node.operands.rhs) |node_idx| {
        const node = self.nodes[node_idx];
        const token = self.source.tokens[node.token];

        switch (node.tag) {
            .builtin => {
                astgen_assert(self.node_is_null_or(node.operands.lhs, .container));
                astgen_assert(self.node_is(node.operands.rhs, .composite));
                const composite = self.nodes[node.operands.rhs];
                astgen_assert(self.node_is_null_or(composite.operands.lhs, .container));
                astgen_assert(self.node_is_null_or(composite.operands.rhs, .container));

                builtin_checklist: switch (token.tag) {
                    .builtin_define => {
                        const define = try self.prepare_define(node) orelse continue;
                        try self.maybe_emit_duplicate_error(define);
                        try self.symbols.put(self.allocator, define.name, .{
                            .token = define.token,
                            .symbol = define.symbol });
                    },
                    .builtin_header => {
                        const header = try self.prepare_header(node) orelse continue;
                        try self.maybe_emit_duplicate_error(header);
                        try self.symbols.put(self.allocator, header.name, .{
                            .token = header.token,
                            .symbol = header.symbol });
                        continue :builtin_checklist .builtin_section;
                    },
                    .builtin_symbols => {
                        const symbols = try self.prepare_symbols(node) orelse continue;
                        // fixme: check for duplicate namespaces?
                        try self.imports.append(self.allocator, symbols);
                    },

                    .builtin_region,
                    .builtin_section => {
                        // fixme: empty regions will throw an error
                        // fixme: empty sections aren't a Null opaque
                        astgen_assert(self.node_is(composite.operands.rhs, .container));
                        // if (self.is_null(composite.operands.rhs))
                        //     return;
                        const opaque_ = self.nodes[composite.operands.rhs];
                        try self.prepare_opaque_container(opaque_);
                    },

                    // nothing to do here
                    .builtin_align,
                    .builtin_barrier => {},

                    // transparent in the AST
                    .builtin_end => astgen_failure(),

                    // non-builtin tokens shouldn't be in node tags
                    else => astgen_failure()
                }
            },

            .instruction => {
                astgen_assert(self.node_is_null_or(node.operands.lhs, .container));
                astgen_assert(self.node_is_null_or(node.operands.rhs, .composite));

                if (self.is_null(node.operands.rhs))
                    continue;
                const composite = self.nodes[node.operands.rhs];
                astgen_assert(self.node_is_null_or(composite.operands.lhs, .container));
                astgen_assert(self.node_is_null_or(composite.operands.rhs, .modifier));

                if (self.is_null(composite.operands.lhs))
                    continue;
                var labels = ContainerIterator.init_index(self, composite.operands.lhs);

                while (try labels.gracefully_expect(.label)) |label_node| {
                    astgen_assert(self.is_null(label_node.operands.lhs));
                    astgen_assert(self.is_null(label_node.operands.rhs));

                    const label = try self.prepare_label(label_node, @intCast(node_idx)) orelse continue;
                    try self.maybe_emit_duplicate_error(label);
                    try self.symbols.put(self.allocator, label.name, .{
                        .token = label.token,
                        .symbol = label.symbol });
                }
            },

            else => astgen_failure()
        }
    }
}

const NamedSymbol = struct {
    name: []const u8,
    token: Token,
    symbol: Symbol
};

fn maybe_emit_duplicate_error(self: *AsmSemanticAir, symbol: NamedSymbol) !void {
    if (self.symbols.get(symbol.name)) |existing_symbol| {
        try self.add_error(error.DuplicateSymbol, .{ symbol.name, symbol.token });
        try self.add_error(error.NoteDefinedHere, .{ Token.string("previously"), existing_symbol.token });
    }
}

fn maybe_emit_sentinel_error(self: *AsmSemanticAir, sentinel_index: AsmAst.Index) !void {
    astgen_assert(self.node_is_null_or(sentinel_index, .integer));
    if (sentinel_index != AsmAst.Null) {
        const sentinel_node = self.nodes[sentinel_index];
        const sentinel_token = self.source.tokens[sentinel_node.token];
        try self.add_error(error.UselessSentinel, sentinel_token);
    }
}

fn maybe_emit_nonempty_modifier_error(self: *AsmSemanticAir, token: Token) !void {
    astgen_assert(token.tag == .modifier);
    const string = token.location.slice(self.source.buffer);
    if (string.len > 1)
        try self.add_error(error.NonEmptyModifier, .{ string, token });
}

fn emit_resolved_expected_error(
    self: *AsmSemanticAir,
    expected_token: anytype,
    origin_token: Token,
    resolved_token: Token
) !void {
    try self.add_error(error.Expected, .{ expected_token, origin_token });
    if (!origin_token.location.eql(resolved_token.location))
        try self.add_error(error.NoteDefinedHere, .{ resolved_token.tag, resolved_token });
}

fn emit_resolved_generic_error(
    self: *AsmSemanticAir,
    message: anytype,
    topic: anytype,
    origin_token: Token,
    resolved_token: Token
) !void {
    try self.add_error(error.GenericToken, .{ message, topic, origin_token });
    if (!origin_token.location.eql(resolved_token.location))
        try self.add_error(error.NoteDefinedHere, .{ resolved_token.tag, resolved_token });
}

fn prepare_define(self: *AsmSemanticAir, node: AsmAst.Node) !?NamedSymbol {
    const composite = self.nodes[node.operands.rhs];
    const options_ = if (self.node_unwrap(composite.operands.lhs)) |options_|
        try self.parse_options(options_, &.{ .expose }) else
        null;
    defer self.free_options(options_);
    const define_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, define_token);

    const name_node = try arguments.expect(.identifier) orelse return null;
    const name_token = self.source.tokens[name_node.token];
    const name = name_token.location.slice(self.source.buffer);

    const value_node = try arguments.expect_any() orelse return null;
    try arguments.expect_end();
    astgen_assert(self.is_null(composite.operands.rhs));

    const define = Symbol.Define {
        .value_node = value_node,
        .is_public = self.contains_option(options_, .expose) };
    return .{
        .name = name,
        .token = define_token,
        .symbol = .{ .define = define } };
}

fn prepare_header(self: *AsmSemanticAir, node: AsmAst.Node) !?NamedSymbol {
    const composite = self.nodes[node.operands.rhs];
    const options_ = if (self.node_unwrap(composite.operands.lhs)) |options_|
        try self.parse_options(options_, &.{ .expose }) else
        null;
    defer self.free_options(options_);
    const header_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, header_token);

    const name_node = try arguments.expect(.identifier) orelse return null;
    const name_token = self.source.tokens[name_node.token];
    const name = name_token.location.slice(self.source.buffer);

    while (try arguments.gracefully_expect(.identifier) != null) {}
    astgen_assert(self.node_is_null_or(composite.operands.rhs, .container));

    const header = Symbol.Header {
        .arguments = .{
            .lhs = arguments.start + 1, // skip name
            .rhs = arguments.end },
        .content = if (self.not_null(composite.operands.rhs))
            self.nodes[composite.operands.rhs].operands else
            .{},
        .is_public = self.contains_option(options_, .expose) };
    return .{
        .name = name,
        .token = header_token,
        .symbol = .{ .header = header } };
}

fn prepare_symbols(self: *AsmSemanticAir, node: AsmAst.Node) !?SymbolFile {
    const composite = self.nodes[node.operands.rhs];
    if (self.node_unwrap(composite.operands.lhs)) |options_|
        _ = try self.parse_options(options_, &.{});
    const symbols_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, symbols_token);

    const path_string_node = try arguments.expect(.string) orelse return null;
    const path_string_token = self.source.tokens[path_string_node.token];
    const path_string = path_string_token.content_slice(self.source.buffer);
    astgen_assert(path_string_token.tag == .string_literal);
    try self.maybe_emit_sentinel_error(path_string_node.operands.lhs);

    const namespace_node = try arguments.gracefully_expect(.identifier);
    const namespace = if (namespace_node) |namespace_node_|
        self.source.tokens[namespace_node_.token].location.slice(self.source.buffer) else
        null;
    try arguments.expect_end();
    astgen_assert(self.is_null(composite.operands.rhs));

    return .{
        .path = path_string,
        .namespace = namespace };
}

const Option = enum {
    expose,
    noelimination
};

const options_map = std.StaticStringMap(Option).initComptime(.{
    .{ "expose", .expose },
    .{ "noelimination", .noelimination }
});

/// If the allow list is empty, it's guaranteed that there's no need to call
/// free on the returned slice.
fn parse_options(self: *AsmSemanticAir, node: AsmAst.Node, allow_list: []const Option) ![]const Option {
    astgen_assert(node.tag == .container);
    const len = node.operands.rhs - node.operands.lhs;

    var options_ = try std
        .ArrayList(Option)
        .initCapacity(self.allocator, @min(len, allow_list.len));
    errdefer options_.deinit();

    for (node.operands.lhs..node.operands.rhs) |index| {
        astgen_assert(self.node_is(@intCast(index), .option));
        const option_node = self.nodes[index];
        astgen_assert(self.not_null(option_node.token));
        const option_token = self.source.tokens[option_node.token];
        astgen_assert(option_token.tag == .option);

        const option_string = option_token.location.slice(self.source.buffer);
        const option = options_map.get(option_string) orelse astgen_failure();

        if (std.mem.indexOfScalar(Option, allow_list, option) == null)
            try self.add_error(error.UnsupportedOption, option_token) else
            try options_.append(option);
    }

    if (allow_list.len == 0) {
        std.debug.assert(options_.items.len == 0);
        options_.deinit();
        return &.{};
    }

    return try options_.toOwnedSlice();
}

fn contains_option(self: *AsmSemanticAir, options_: ?[]const Option, option: Option) bool {
    _ = self;
    return if (options_) |options__|
        std.mem.indexOfScalar(Option, options__, option) != null else
        false;
}

fn free_options(self: *AsmSemanticAir, options_: ?[]const Option) void {
    if (options_) |options__|
        self.allocator.free(options__);
}

fn prepare_label(self: *AsmSemanticAir, node: AsmAst.Node, instr_index: AsmAst.Index) !?NamedSymbol {
    const label_token = self.source.tokens[node.token];
    astgen_assert(label_token.tag == .label or label_token.tag == .private_label);

    const is_public = label_token.tag == .label;
    const label_name = label_token.content_slice(self.source.buffer);
    astgen_assert(self.is_null(node.operands.rhs));

    const label = Symbol.Label {
        .instr_node = instr_index,
        .is_public = is_public };
    return .{
        .name = label_name,
        .token = label_token,
        .symbol = .{ .label = label } };
}

pub fn resolve_imports(self: *AsmSemanticAir, units: *const SemanticAirMap) !void {
    const qcu = self.qcu orelse @panic("AsmSemanticAir: freestanding");
    for (self.imports.items) |*import| {
        if (try qcu.eql(import.path)) {
            try self.add_error(error.Generic, .{ "cannot import itself", import.path });
            continue;
        }

        const id = qcu.resolve(import.path) orelse {
            try self.add_error(error.Generic, .{ "file not found", import.path });
            continue;
        };

        import.sema_unit = units.get(id) orelse {
            try self.add_error(error.Generic, .{ "missing sema unit", import.path });
            continue;
        };
    }
}

/// May only be called once, and subsequent calls are considered undefined
/// behaviour.
pub fn semantic_analyse(self: *AsmSemanticAir) !void {
    try self.analyse_container(self.nodes[0]);
}

fn analyse_container(self: *AsmSemanticAir, parent_node: AsmAst.Node) !void {
    for (parent_node.operands.lhs..parent_node.operands.rhs) |node_idx| {
        const node = self.nodes[node_idx];
        const token = self.source.tokens[node.token];

        switch (node.tag) {
            .builtin => switch (token.tag) {
                .builtin_align => try self.emit_align(node),
                .builtin_barrier => try self.emit_barrier(node),

                .builtin_region => {
                    const section = self.current_section orelse astgen_failure();
                    const begin_address = find_section_size(section);
                    const composite = self.nodes[node.operands.rhs];
                    const opaque_ = self.nodes[composite.operands.rhs];
                    try self.analyse_container(opaque_);

                    const len = find_section_size(section) - begin_address;
                    try self.emit_region(node, len);
                },

                .builtin_section => {
                    self.emit_section(node) catch |err| switch (err) {
                        error.SectionCreateFailed => continue,
                        else => |err_| return err_
                    };

                    const composite = self.nodes[node.operands.rhs];
                    const opaque_ = self.nodes[composite.operands.rhs];
                    try self.analyse_container(opaque_);
                },

                // nothing to do here
                .builtin_define,
                .builtin_header,
                .builtin_symbols => {},

                // transparent in the AST
                .builtin_end => astgen_failure(),

                // non-builtin tokens shouldn't be in the node tags
                else => astgen_failure()
            },

            .instruction => try self.emit_addressable(@intCast(node_idx)),

            else => astgen_failure()
        }
    }
}

fn emit_align(self: *AsmSemanticAir, node: AsmAst.Node) !void {
    const composite = self.nodes[node.operands.rhs];
    if (self.node_unwrap(composite.operands.lhs)) |options_|
        _ = try self.parse_options(options_, &.{});
    const align_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, align_token);

    const alignment_node = try arguments.expect(.integer) orelse return;
    const alignment_token = self.source.tokens[alignment_node.token];
    const alignment = alignment_token.location.slice(self.source.buffer);
    try arguments.expect_end();

    const alignment_ = std.fmt.parseInt(usize, alignment, 0) catch astgen_failure();
    if (!std.math.isPowerOfTwo(alignment_))
        return try self.add_error(error.AlignPowerTwo, .{ alignment_, align_token });
    const section = self.current_section orelse astgen_failure();
    const current_address = find_section_size(section);
    const padding = find_available_mask(current_address, alignment_) - current_address;

    try section.content.append(self.allocator, .{ .ld_padding = .{ padding } });
    section.alignment = @max(section.alignment, alignment_);
}

fn emit_barrier(self: *AsmSemanticAir, node: AsmAst.Node) !void {
    const composite = self.nodes[node.operands.rhs];
    if (self.node_unwrap(composite.operands.lhs)) |options_|
        _ = try self.parse_options(options_, &.{});
    const barrier_token = self.source.tokens[node.token];
    try ContainerIterator.expect_empty(self, node.operands.lhs, barrier_token);

    const existing_section = self.current_section orelse return astgen_failure();
    const section = try self.allocator.create(Section);
    section.* = .{ .is_removable = existing_section.is_removable };

    existing_section.append(section);
    self.current_section = section;
}

fn emit_region(self: *AsmSemanticAir, node: AsmAst.Node, opaque_len: usize) !void {
    const composite = self.nodes[node.operands.rhs];
    if (self.node_unwrap(composite.operands.lhs)) |options_|
        _ = try self.parse_options(options_, &.{});
    const region_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, region_token);

    const size_node = try arguments.expect(.integer) orelse return;
    const size_token = self.source.tokens[size_node.token];
    const size = size_token.location.slice(self.source.buffer);
    try arguments.expect_end();

    const size_ = std.fmt.parseInt(usize, size, 0) catch astgen_failure();
    if (opaque_len > size_)
        return try self.add_error(error.RegionExceedsSize, .{ opaque_len, size_, region_token });
    const section = self.current_section orelse return astgen_failure();
    const padding = size_ - opaque_len;
    try section.content.append(self.allocator, .{ .ld_padding = .{ padding } });
}

fn emit_section(self: *AsmSemanticAir, node: AsmAst.Node) !void {
    const composite = self.nodes[node.operands.rhs];
    const options_ = if (self.node_unwrap(composite.operands.lhs)) |options_|
        try self.parse_options(options_, &.{ .noelimination }) else
        null;
    defer self.free_options(options_);
    const section_token = self.source.tokens[node.token];
    var arguments = ContainerIterator.init_index_context(self, node.operands.lhs, section_token);

    const name_node = try arguments.expect(.identifier) orelse return error.SectionCreateFailed;
    const name_token = self.source.tokens[name_node.token];
    const name = name_token.location.slice(self.source.buffer);
    try arguments.expect_end();

    const section = try self.allocator.create(Section);
    section.* = .{ .is_removable = !self.contains_option(options_, .noelimination) };

    if (self.sections.get(name)) |existing_section|
        existing_section.append(section) else
        try self.sections.put(self.allocator, name, section);
    self.current_section = section;
}

pub const Instruction = union(Tag) {

    cli,
    ast: struct { GpRegister },
    mst: struct { SpRegister, u16 },
    mst_: struct { SpRegister, u16 },
    mstw: struct { SpRegister, u16 },
    mstw_: struct { SpRegister, u16 },
    mld: struct { SpRegister, u16 },
    mld_: struct { SpRegister, u16 },
    mldw: struct { SpRegister, u16 },
    mldw_: struct { SpRegister, u16 },

    // mst: struct { u1, u2, LinkNode },
    // mstd: struct { u1, u2, LinkNode },

    // pseudoinstructions
    u8: struct { u8 },
    u16: struct { u16 },
    u24: struct { u24 },
    i8: struct { i8 },
    i16: struct { i16 },
    i24: struct { i24 },
    ascii: struct { StringContent },
    reserve: struct { TypeSize, u16 },

    // adds fixed zero bytes
    ld_padding: struct { usize },

    // expression during link time
    // ld_expression: LinkNode.Expression,

    // symbol reference during link time
    // symbol address, section address, calculated offset from offset and
    // name
    // ld_symbol: LinkNode.Symbol,

    pub const Tag = enum {

        cli,
        ast,
        mst,
        mst_,
        mstw,
        mstw_,
        mld,
        mld_,
        mldw,
        mldw_,
        u8,
        u16,
        u24,
        i8,
        i16,
        i24,
        ascii,
        reserve,
        ld_padding,
        // ld_expression,
        // ld_symbol,

        pub fn basic_size(self: Tag) usize {
            return switch (self) {
                .cli,
                .ast => 1,
                .mst,
                .mst_,
                .mstw,
                .mstw_,
                .mld,
                .mld_,
                .mldw,
                .mldw_ => 3,

                .u8, .i8 => 1,
                .u16, .i16 => 2,
                .u24, .i24 => 3,

                .ascii,
                .reserve,
                .ld_padding => 0
            };
        }
    };

    pub const GpRegister = enum {
        zr,
        ra,
        rb,
        rc,
        rd,
        rx,
        ry,
        rz
    };

    pub const gp_register_map = std.StaticStringMap(GpRegister).initComptime(.{
        .{ "zr", .zr },
        .{ "ra", .ra },
        .{ "rb", .rb },
        .{ "rc", .rc },
        .{ "rd", .rd },
        .{ "rx", .rx },
        .{ "ry", .ry },
        .{ "rz", .rz }
    });

    pub const SpRegister = enum {
        sp,
        sf,
        adr,
        zr
    };

    pub const sp_register_map = std.StaticStringMap(SpRegister).initComptime(.{
        .{ "sp", .sp },
        .{ "sf", .sf },
        .{ "adr", .adr },
        .{ "zr", .zr }
    });

    pub const StringContent = struct {

        memory: []const u8,
        sentinel: ?u8,

        pub fn size(self: StringContent) usize {
            const sentinel_: usize = if (self.sentinel != null) 1 else 0;
            return self.memory.len + sentinel_;
        }
    };

    pub const TypeSize = struct {
        size: u16
    };

    pub const instruction_map = std.StaticStringMap(Tag).initComptime(.{
        .{ "cli", .cli },
        .{ "ast", .ast },
        .{ "mst", .mst },
        .{ "mstw", .mstw },
        .{ "mld", .mld },
        .{ "mldw", .mldw },
        .{ "u8", .u8 },
        .{ "u16", .u16 },
        .{ "u24", .u24 },
        .{ "i8", .i8 },
        .{ "i16", .i16 },
        .{ "i24", .i24 },
        .{ "ascii", .ascii },
        .{ "reserve", .reserve }
    });

    pub const modifier_map = std.StaticStringMap(Tag).initComptime(.{
        .{ "mst", .mst_ },
        .{ "mstw", .mstw_ },
        .{ "mld", .mst_ },
        .{ "mldw", .mldw_ }
    });

    comptime {
        // Zig comptime validation, hell yeah!
        for (@typeInfo(Tag).@"enum".fields) |instruction_tag| {
            if (std.mem.startsWith(u8, instruction_tag.name, "ld_"))
                continue;
            const real_instruction = std.mem.trimRight(u8, instruction_tag.name, "_");
            const mapping: ?Instruction.Tag = instruction_map.get(real_instruction) orelse
                modifier_map.get(real_instruction);
            if (mapping) |mapping_| {
                const real_mapping = std.mem.trimRight(u8, instruction_tag.@"name", "_");
                if (!std.mem.eql(u8, real_mapping, @tagName(mapping_)))
                    @compileError("bug: mismatching mapping/instruction: " ++ @tagName(mapping_) ++ " / " ++ real_instruction);
            } else @compileError("bug: unmapped instruction: " ++ real_instruction);
        }
    }

    pub fn size(self: Instruction) usize {
        return switch (self) {
            .ascii => |args| args[0].size(),
            .reserve => |args| args[0].size * args[1],
            .ld_padding => |args| args[0],
            else => std.meta.activeTag(self).basic_size()
        };
    }
};

// pub const LinkNode = union(enum) {

//     constant: usize,
//     expression: AsmAst.Index,   // to expression section
//     symbol: AsmAst.Index,       // to symbols section

//     pub const Expression = struct {

//         tag: Tag,
//         lhs: AsmAst.Index,
//         rhs: AsmAst.Index,

//         pub const Tag = enum {
//             add,
//             constant
//         };
//     };

//     pub const Symbol = struct {
//         section: AsmAst.Index,
//         offset: AsmAst.Index,
//         label: []const u8
//     };
// };

fn emit_addressable(self: *AsmSemanticAir, index: AsmAst.Index) !void {
    const node = self.nodes[index];
    astgen_assert(self.node_is(index, .instruction));
    astgen_assert(self.node_is_null_or(node.operands.lhs, .container));
    astgen_assert(self.node_is_null_or(node.operands.rhs, .composite));

    const token = self.source.tokens[node.token];
    astgen_assert(token.tag == .instruction or
        token.tag == .pseudo_instruction or
        token.tag == .identifier);

    const labels: AsmAst.IndexRange,
    const is_modified: bool = if (self.node_unwrap(node.operands.rhs)) |composite| blk: {
        astgen_assert(self.node_is_null_or(composite.operands.lhs, .container));
        astgen_assert(self.node_is_null_or(composite.operands.rhs, .modifier));

        const label_range: AsmAst.IndexRange = if (self.node_unwrap(composite.operands.lhs)) |container_node|
            container_node.operands else
            .{};
        const modifier_token = if (self.node_unwrap(composite.operands.rhs)) |modifier_node|
            self.source.tokens[modifier_node.token] else
            null;
        if (modifier_token) |modifier_token_|
            try self.maybe_emit_nonempty_modifier_error(modifier_token_);
        break :blk .{ label_range, modifier_token != null };
    } else .{ .{}, false };

    const section = self.current_section orelse return astgen_failure();
    const current_address = find_section_size(section);
    try self.emit_labels(current_address, labels);

    const arguments = if (self.node_unwrap(node.operands.lhs)) |arguments_node|
        arguments_node.operands else
        null;
    try self.emit_instructions(token, is_modified, arguments);
}

fn emit_labels(self: *AsmSemanticAir, address: usize, labels: AsmAst.IndexRange) !void {
    // fixme: for all labels, append to symbol table
    _ = self;
    _ = address;
    _ = labels;
}

fn emit_instructions(self: *AsmSemanticAir, token: Token, is_modified: bool, arguments: ?AsmAst.IndexRange) !void {
    const section = self.current_section orelse return astgen_failure();
    const string = token.location.slice(self.source.buffer);

    switch (token.tag) {
        .instruction,
        .pseudo_instruction => {
            const tag = if (is_modified)
                Instruction.modifier_map.get(string) else
                Instruction.instruction_map.get(string);
            astgen_assert(is_modified or tag != null);

            if (tag == null and is_modified)
                return try self.add_error(error.ModifiedInstructionUnknown, token);
            const instruction = try self.cast_arguments(token, tag.?, arguments) orelse return;
            try section.content.append(self.allocator, instruction);
        },

        .identifier => {
            if (!std.mem.startsWith(u8, string, "@") or string.len == 1) {
                try self.add_error(error.InstructionUnknown, token);
                // fixme: lookup imports
                const symbol = self.symbols.get(string) orelse return;
                if (symbol.symbol == .header)
                    try self.add_error(error.NoteDidYouMean, .{ "call the header @", string, symbol.token });
                return;
            }

            // fixme: add identifier header lookup and recursive analyse_container() call
            // ...
        },

        else => unreachable
    }
}

fn cast_arguments(self: *AsmSemanticAir, token: Token, instruction_tag: Instruction.Tag, arguments: ?AsmAst.IndexRange) !?Instruction {
    inline for (@typeInfo(Instruction).@"union".fields) |instruction| {
        if (std.mem.eql(u8, instruction.name, @tagName(instruction_tag))) {
            const Arguments = instruction.@"type";
            const arguments_len = if (arguments) |arguments_|
                arguments_.rhs - arguments_.lhs else
                0;
            const fields = if (Arguments != void)
                @typeInfo(Arguments).@"struct".fields else
                .{};
            if (fields.len != arguments_len) {
                try self.add_error(error.ExpectedArgumentsLen, .{ token, fields.len, arguments_len });
                return null;
            }

            if (fields.len == 0)
                return @unionInit(Instruction, instruction.name, {});
            var iterator = ContainerIterator.init_range(self, arguments.?);
            var casted_arguments: Arguments = undefined;

            inline for (fields, 0..) |argument, i| {
                const Type = argument.@"type";
                const user_argument = iterator.next() orelse unreachable;

                casted_arguments[i] = switch (Type) {
                    Instruction.GpRegister => try self.cast_gp_register(user_argument),
                    Instruction.SpRegister => try self.cast_sp_register(user_argument),
                    u8, u16, u24, i8, i16, i24 => try self.cast_expression(Type, user_argument),
                    Instruction.StringContent => try self.cast_string_content(user_argument),
                    Instruction.TypeSize => try self.cast_type_size(user_argument),

                    usize => astgen_failure(),
                    else => @compileError("bug: missing casting implementation for " ++ @typeName(Type))
                } orelse return null;
            }

            return @unionInit(Instruction, instruction.name, casted_arguments);
        }
    }

    astgen_failure();
}

fn cast_gp_register(self: *AsmSemanticAir, node: AsmAst.Node) !?Instruction.GpRegister {
    // fixme: expand @define to unary
    const token = self.source.tokens[node.token];
    const string = token.content_slice(self.source.buffer);

    return Instruction.gp_register_map.get(string) orelse {
        try self.emit_resolved_expected_error(Token.string("a general-purpose register"), self.source.tokens[node.token], token);
        return null;
    };
}

fn cast_sp_register(self: *AsmSemanticAir, node: AsmAst.Node) !?Instruction.SpRegister {
    // fixme: expand @define to unary
    const token = self.source.tokens[node.token];
    const string = token.content_slice(self.source.buffer);

    return Instruction.sp_register_map.get(string) orelse {
        try self.emit_resolved_expected_error(Token.string("a special-purpose register"), self.source.tokens[node.token], token);
        return null;
    };
}

fn cast_string_content(self: *AsmSemanticAir, node: AsmAst.Node) !?Instruction.StringContent {
    // fixme: expand @define to unary
    const token = self.source.tokens[node.token];
    const string = token.content_slice(self.source.buffer);

    if (token.tag != .string_literal) {
        try self.emit_resolved_expected_error(AsmAst.Node.Tag.string, self.source.tokens[node.token], token);
        return null;
    }

    const sentinel = if (self.node_unwrap(node.operands.lhs)) |sentinel_node|
        try self.cast_numeric_literal(u8, sentinel_node) else
        null;
    return .{
        .memory = string,
        .sentinel = sentinel };
}

const inherit_base = 0;

fn cast_numeric_literal(self: *AsmSemanticAir, comptime T: type, node: AsmAst.Node) !?T {
    // fixme: expand @define to unary
    const token = self.source.tokens[node.token];
    const string = token.location.slice(self.source.buffer);

    if (token.tag != .numeric_literal) {
        try self.emit_resolved_expected_error(AsmAst.Node.Tag.integer, self.source.tokens[node.token], token);
        return null;
    }

    return std.fmt.parseInt(T, string, inherit_base) catch |err| switch (err) {
        error.InvalidCharacter => astgen_failure(),
        error.Overflow => {
            try self.emit_resolved_generic_error("numeric literal doesn't fit in type", @typeName(T), self.source.tokens[node.token], token);
            return null;
        }
    };
}

// sub(int, ref) = illegal
// sub(ref, ref) = diff/int
// sub(ref, int) = offset/int
// sub(int, int) = int
// add(int, ref) = offset/int
// add(ref, ref) = illegal
// add(ref, int) = offset/int
// add(int, int) = int
// lsh/rsh/mult(int, ref) = illegal
// lsh/rsh/mult(ref, ref) = illegal
// lsh/rsh/mult(ref, int) = illegal
// lsh/rsh/mult(int, int) = int
fn cast_expression(self: *AsmSemanticAir, comptime T: type, node: AsmAst.Node) !?T {
    // fixme: expression support, not only unsigned integers
    // fixme: lower @define
    return self.cast_numeric_literal(T, node);
}

fn cast_type_size(self: *AsmSemanticAir, node: AsmAst.Node) !?Instruction.TypeSize {
    // fixme: expand @define to unary
    const token = self.source.tokens[node.token];
    const string = token.location.slice(self.source.buffer);

    if (token.tag != .instruction and
        token.tag != .pseudo_instruction and
        token.tag != .identifier
    ) {
        try self.add_error(error.Expected, .{ Token.string("a basic opaque"), token });
        return null;
    }

    const size = switch (token.tag) {
        .instruction,
        .pseudo_instruction => Instruction.instruction_map
            .get(string).?
            .basic_size(),
        // fixme: get size of header (and check if header exists)
        // won't support recursive headers as arguments aren't inputted
        .identifier => 0,
        else => astgen_failure()
    };

    return .{ .size = @intCast(size) };
}

// fixme: lower_symbol()
// fixme: lower_unary_symbol()

// Tests

const options = @import("options");
const Tokeniser = @import("AsmTokeniser.zig");

const stderr = std.io
    .getStdErr()
    .writer();

fn testSema(input: [:0]const u8) !struct { AsmAst, AsmSemanticAir } {
    var tokeniser = Tokeniser.init(input);
    const source = try Source.init(std.testing.allocator, &tokeniser);
    errdefer source.deinit();
    var ast = try AsmAst.init(std.testing.allocator, source);
    errdefer ast.deinit();

    for (ast.errors) |err|
        try err.write("test.s", input, stderr);
    try std.testing.expect(ast.errors.len == 0);

    return .{ ast, try AsmSemanticAir.init_freestanding(std.testing.allocator, source, ast.nodes) };
}

fn testSemaFree(ast: *AsmAst, sema: *AsmSemanticAir) void {
    ast.deinit();
    sema.deinit();
    sema.source.deinit();
}

fn testSema1(input: [:0]const u8) !void {
    var ast, var sema = try testSema(input);
    defer testSemaFree(&ast, &sema);

    if (options.dump) {
        try stderr.print("Imports ({}):\n", .{ sema.imports.items.len });
        for (sema.imports.items) |import|
            try stderr.print("    {s} = {s}\n", .{ import.namespace orelse "_", import.path });
        try stderr.print("Symbols ({}):\n", .{ sema.symbols.count() });
        for (sema.symbols.keys()) |symbol_name| {
            const symbol = sema.symbols.get(symbol_name) orelse unreachable;
            switch (symbol.symbol) {
                .label => |label| try stderr.print("    {s} = instr:{} public:{}\n", .{
                    symbol_name,
                    label.instr_node,
                    label.is_public }),
                .define => |define| try stderr.print("    {s} = root:{} public:{}\n", .{
                    symbol_name,
                    define.value_node,
                    define.is_public }),
                .header => |header| try stderr.print("    {s} = args:{}..{} nodes:{}..{} public:{}\n", .{
                    symbol_name,
                    header.arguments.lhs,
                    header.arguments.rhs,
                    header.content.lhs,
                    header.content.rhs,
                    header.is_public })
            }
        }
    }

    for (sema.errors.items) |err|
        try err.write("test.s", input, stderr);
    try std.testing.expect(sema.errors.items.len == 0);
}

fn testSema2(input: [:0]const u8) !void {
    var ast, var sema = try testSema(input);
    defer testSemaFree(&ast, &sema);

    try sema.semantic_analyse();

    if (options.dump) {
        for (sema.sections.keys()) |section_name| {
            const section = sema.sections.get(section_name) orelse unreachable;
            var dumping_section: ?*Section = section;
            try stderr.print("@section {s} (align {})\n", .{ section_name, section.alignment });

            while (dumping_section) |dumping_section_| {
                for (dumping_section_.content.items) |instr| {
                    switch (instr) {
                        inline else => |instr_| try stderr.print("    {s}({}) : {}\n", .{ @tagName(instr), instr.size(), instr_ })
                    }
                }

                if (dumping_section_.next) |next_dumping_section|
                    try stderr.print("@barrier (align {})\n", .{ next_dumping_section.alignment });
                dumping_section = dumping_section_.next;
            }
        }
    }

    for (sema.errors.items) |err|
        try err.write("test.s", input, stderr);
    try std.testing.expect(sema.errors.items.len == 0);
}

test "full fledge" {
    try testSema1(
        \\@symbols "foo", foo
        \\@symbols "bar"
        \\@define(expose) foo, bar
        \\@header bar
        \\          ast
        \\@end
        \\@section foo
        \\          ast
        \\.aaa:     ast
        \\bbb:      ast
        \\@define awd, awd
    );

    try testSema2(
        \\@define foo, bar
        \\@define bar, 5
        \\@header roo, doo
        \\.doo:         ast
        \\@end
        \\@section(noelimination) foo
        \\          @region 32
        \\              cli
        \\              ast rb
        \\              @align 4
        \\              u16 0xFFFF
        \\              u8 0b10101111
        \\              ascii "foo" 0
        \\              reserve u24, 4
        \\              mst' sf, 0xFFFF
        \\              mldw sf, 0xFFFF
        \\          @end
    );
}
